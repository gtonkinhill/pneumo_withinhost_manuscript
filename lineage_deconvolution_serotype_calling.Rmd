---
title: "Lineage deconvolution and serotype calling"
author: "Gerry Tonkin-Hill"
date: "`r Sys.Date()`"
output: 
  html_document:
    fig_width: 12
    fig_height: 8
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(fig.width=20, fig.height=12,
                      echo=TRUE, warning=FALSE, message=FALSE,
                      tidy=TRUE)
options(stringsAsFactors = FALSE)
```


## Deconvolution using mSWEEP/mGEMS

The mGEMS deconvolution pipeline was used to generate fastq files for each GPSC present within each sample. This relied on a cleaned reference database of whole genome assemblies of *S. pneumoniae* which comprised 20,047 genomes from the Global Pneumococcal Sequencing Project database (Gladstone et al. 2019). Included in this subset were 2,663 genome assemblies from the original genome sequencing study of the Maela camp that relied on single colony picks (Chewapreecha et al. 2014). The PopPunk algorithm was used to assign each of these genomes to their respective Global Pneumococcal Sequencing Cluster (Lees et al. 2019). 

We also made use of the Mash Screen algorithm as an additional filter to prevent false positive in from the mGEMS analysis (Ondov et al. 2019).

These commands were also run on the artificial pneumococcal mixture data provided in Knight et al., 2019 to aid in the verification of the pipeline.

**Note:** The commands listed in this section are reported for reproducibility purposes but due the large computational requirements are not set up to be run directly from the markdown file.

### Running mGEMS

The initial step of the mGEMS pipeline relies on building a Themisto (v0.2.0-1-gd8e44f5) index.

```{bash, eval=FALSE}
mkdir themisto_index
cd themisto_index
build_index --k 31 --input-file combined_gps_fastas.fasta --auto-colors --index-dir ./ --temp-dir ./tmp/ --mem-megas 20000 --n-threads 30
```

We then used a python script to run the mSWEEP quantification algorithm followed by the mGEMS deconvolution pipeline.

Following deconvolution this script then assembles the deconvoluted samples using Shovill (v1.0.4) and runs seroba (v1.0.2) to identify the serotype of each of the deconvoluted read sets. 

This script required a very large amount of computational resources and was run in parallel using Microsoft's cloud compute.

The resulting output is provided as part of the supplementary data that accompanies this repository available on Zenodo.

```{bash, eval=FALSE}
for r in ./fastq_files/*_1.fastq.gz; 
do 
python ./scripts/run_mSWEEP_pipeline.py --r $r --r2 "${r/_1\.fastq\.gz/_2\.fastq\.gz}" -o ./deconvoluted/ -t 15 --mem 20000 
done
```

### Running Mash

To remove false positives in the mGEMS output we also run Mash Screen (v2.2.2) on each of the deconvoluted fastq files. 

```{bash, eval=FALSE}
for f in ./deconvoluted/*/*_1.fastq.gz
do
python ./scripts/run_mash_pipeline.py --r1 $f --r2 "${f/_1.fastq.gz/_2.fastq.gz}" -o ./mash/ -t 4
done
```

### Serotype Calling using Serocall

In addition to running Seroba on each of the deconvoluted lineages we also also ran the Serocall algorithm (Knight et al. 2019) on the potentially mixed samples. We used a modified database in order to keep up to date with the Seroba serotype database. This can be found at https://github.com/gtonkinhill/SeroCall

```{bash, eval=FALSE}
for f in ./fastq_files/*_1.fastq.gz
do
prefix=$(basename $f _1.fastq.gz)
serocall -t 4 -o ./serocalls/${prefix} $f "${f/_1.fastq.gz/_2.fastq.gz}" 
done
```

##Post Processing and Verification of Results

```{r}
library(tidyverse)
library(data.table)
library(ggVennDiagram)
library(ggthemes)
library(lme4)
library(lubridate)
library(broom)
```

##Verification on known samples

The results from each of the runs described above were combined into summary tables provided in the data folder of this repository. We initially focus on the artificial laboratory mixtures of Knight et al., 2019.

```{r}
abundances <- fread("./data/msweep_verification/combined_msweep_abundances.txt", data.table = FALSE) %>% as_tibble()
mash <- fread("./data/msweep_verification/combined_mash_screen.tab", data.table = FALSE, 
              col.names = c("sample", "identity", "shared-hashes", "median-multiplicity", "p-value", "query-ID","group")) %>% as_tibble()
single_mash <- fread("./data/msweep_verification/combined_single_mash_results.tab", data.table = FALSE, 
                     col.names = c("sample", "identity", "shared-hashes", "median-multiplicity", "p-value", "query-ID","group")) %>% as_tibble()
single_poppunk <- fread("./data/msweep_verification/GPSC_assignment_external_clusters.csv", data.table = FALSE) %>% as_tibble()
seroba <- fread("./data/msweep_verification/combined_seroba_calls.tab", data.table = FALSE, sep = "\t") %>% as_tibble()
```

We first investigate the precision and recall of the mGEMS pipeline on the artificial laboratory data of Knight et al., 2019.

```{r}
seroba$group <- as.integer(gsub("_seroba", "", seroba$group))

seroba <- merge(seroba, mash, by.x=c('sample','group'), by.y=c('sample', 'group'), all.x = TRUE)
seroba$`shared-hashes` <- map_dbl(str_split(seroba$`shared-hashes`, "/"), ~ as.numeric(.x[[1]]))
seroba$serotype <- gsub("^0", "", seroba$serotype)

seroba_summary <- seroba %>% group_by(sample) %>%
  summarise(
    seroba = list(serotype[serotype!="untypable"]),
    reference = list(unique(unlist(str_split(gsub("mixture_", "", gsub(".*Serotype_", "", sample)), pattern = "_"))))
  )

seroba_summary$TP <- map2_int(seroba_summary$seroba, seroba_summary$reference, ~ length(unique(.x[.x %in% .y])))
seroba_summary$FN <- map2_int(seroba_summary$reference, seroba_summary$TP, ~ length(unique(.x))-.y)
seroba_summary$FP <- map2_int(seroba_summary$seroba, seroba_summary$TP, ~ length(unique(.x))-.y)
seroba_summary$Total <- map_int(seroba_summary$reference, ~ length(unique(.x)))

plot_df <- melt(colSums(seroba_summary[,4:7]))
plot_df$category <- factor(rownames(plot_df), levels = c('FN', 'FP', 'TP', 'Total'))

ggplot(plot_df, aes(x=category, y=value)) + geom_col() +
  theme_bw(base_size = 14) +
  ggtitle(sprintf("Without mash filter - Precision: %.2f  Recall: %.2f", 
                  sum(seroba_summary$TP)/sum(seroba_summary$TP + seroba_summary$FP), 
                  sum(seroba_summary$TP)/sum(seroba_summary$TP + seroba_summary$FN))) +
  ylab('count')
ggsave("./figures/known_msweep_serotype_comparison.png", width = 9, height = 7)
ggsave("./figures/known_msweep_serotype_comparison.pdf", width = 9, height = 7)
```

This indicated that the pipeline could occasionally generate false positives when the sample included a lineage that was not well represented in the database. To combat this we ran the Mash screen algorithm and only accepted those mGEMS calls which shared at lease 990 hashes with a genome assembly from the reference database.

```{r}
seroba_summary <- seroba %>% filter(`shared-hashes`>= 990) %>% 
  group_by(sample) %>%
  summarise(
    seroba = list(serotype[serotype!="untypable"]),
    reference = list(unique(unlist(str_split(gsub("mixture_", "", gsub(".*Serotype_", "", sample)), pattern = "_"))))
  )

seroba_summary$TP <- map2_int(seroba_summary$seroba, seroba_summary$reference, ~ length(unique(.x[.x %in% .y])))
seroba_summary$FN <- map2_int(seroba_summary$reference, seroba_summary$TP, ~ length(unique(.x))-.y)
seroba_summary$FP <- map2_int(seroba_summary$seroba, seroba_summary$TP, ~ length(unique(.x))-.y)
seroba_summary$Total <- map_int(seroba_summary$reference, ~ length(unique(.x)))

plot_df <- melt(colSums(seroba_summary[,4:6]))
plot_df$category <- factor(rownames(plot_df), levels = c('FN', 'FP', 'TP'))
ggplot(plot_df, aes(x=category, y=value, fill=category)) + 
  geom_col() +
  theme_clean(base_size = 16) +
  theme(plot.background = element_blank(),
        legend.background = element_blank()) +
  scale_fill_manual(values = c('#bcbddc', '#bcbddc','#756bb1'), guide=FALSE) +
  ylab("count") + xlab("")

ggsave("./figures/known_msweep_w_mash_serotype_comparison.png", width = 9, height = 7)
ggsave("./figures/known_msweep_w_mash_serotype_comparison.pdf", width = 9, height = 7)
```

This removed the false positives. The remaining false negatives were at very low frequencies in artificial mixtures of 10 lineages. As we only identify a maximum of 6 lineages in our samples this is unlikely to represent a significant limitation to our analyses and we go on to show that this approach is more sensitive than alternatives such as latex sweeps.

###All samples

We now consider the full set of samples.

```{r}
gpsc_serotype_calls <- fread("./data/msweep_analysis/combined_seroba_calls.txt", data.table = FALSE,
                             col.names = c("sample", "GPSC", "serotype", "comment")) %>% as_tibble()
mash_calls <- fread("./data/msweep_analysis/combined_mash_results.tab", data.table = FALSE,
                    col.names = c("sample", "identity", "shared-hashes", "median-multiplicity", 
                                  "p-value", "ref-ID", "GPSC")) %>% as_tibble()
msweep_props <- fread("./data/msweep_analysis/combined_msweep_proportions.csv",
                      data.table = FALSE) %>% as_tibble()

gpsc_serotype_calls$GPSC <- as.numeric(gsub("_seroba.*", "", gpsc_serotype_calls$GPSC))
gpsc_serotype_calls$proportion <- msweep_props$theta[match(paste(gpsc_serotype_calls$sample, gpsc_serotype_calls$GPSC),
                                                           paste(msweep_props$lane, msweep_props$GPSC))]


serocalls <- fread("./data/serocalls/combined_calls.csv", data.table = FALSE) %>% as_tibble()
serocall_data <- fread("./data/serocalls/combined_read_summary.csv", data.table = FALSE) %>% as_tibble()
serocall_coverage <- fread("./data/serocalls/combined_serocall_coverage_counts.txt", data.table = FALSE, fill=TRUE,
                           col.names = c("sample","serotype","start","end","total reads", "unique reads")) %>% as_tibble()

# load some sample metadata and epi
epi <- fread("./data/epi/Pneumo-DEEP_swab_summary.csv", data.table = FALSE) %>% as_tibble()
array_calls <- fread("./data/serocalls/BUGS-SMRU multiple carriage final 04-2010.csv", 
                     data.table = FALSE, header = TRUE, skip = 1) %>% as_tibble()
ena_accessesions <- fread("./data/pneumoDEEP_accessions.csv", data.table = FALSE, 
                          header = FALSE, col.names = c("lane", "ena_acc")) %>% as_tibble()
manifests_qc <- fread("./data/manifest_w_QC.csv", data.table = FALSE) %>% as_tibble()
single_meta <- fread("./data/epi/combined_pnc_swab_house_trans_rf.tsv") %>% as_tibble()

single_lineage_poppunk <- fread("./data/poppunk_gpsc_definitive.csv") %>% as_tibble()

swab_summary <- fread("./data/epi/Pneumo-DEEP_swab_summary.csv") %>% as_tibble()
swab_summary$specdate <- as_date(swab_summary$specdate)
swab_summary$ID <- paste(swab_summary$codenum, swab_summary$category, sep='-')

gpsc_serotype_calls$specnum <- manifests_qc$`DONOR ID (required for EGA)`[match(gpsc_serotype_calls$sample, manifests_qc$`Lane Name`)]
serocall_coverage$specnum <- manifests_qc$`DONOR ID (required for EGA)`[match(serocall_coverage$sample, manifests_qc$`Lane Name`)]
serocall_coverage <- serocall_coverage %>% filter(!is.na(specnum))

mash_calls$specnum <- gpsc_serotype_calls$specnum[match(mash_calls$sample, gpsc_serotype_calls$sample)]
mash_calls <- mash_calls[!is.na(mash_calls$specnum),]
msweep_props$specnum <- manifests_qc$`DONOR ID (required for EGA)`[match(msweep_props$lane, manifests_qc$`Lane Name`)]
```

Take intersection between mash and mSWEEP calls. This is slightly conservative but prevents false positives.

```{r}
mash_calls$`shared-hashes` <- as.numeric(gsub("/.*", "", mash_calls$`shared-hashes`)) 
mash_calls <- mash_calls %>% filter(`shared-hashes` >= 990)

gpsc_serotype_calls <- gpsc_serotype_calls[paste(gpsc_serotype_calls$sample, gpsc_serotype_calls$GPSC) %in% paste(mash_calls$sample, mash_calls$GPSC),]
gpsc_serotype_calls <- map_dfr(unique(gpsc_serotype_calls$sample), ~ {
  temp <- gpsc_serotype_calls %>% filter(sample==.x)
  temp$proportion <- temp$proportion/sum(temp$proportion)
  return(temp)
})

write.table(gpsc_serotype_calls %>% 
              group_by(sample) %>%
              summarise(
                GPCSs=paste(GPSC, collapse = ',')
              ), file='data/gpscs_per_sample_intersect_msweep_mash.tab',
            sep = '\t', quote = FALSE, col.names = TRUE, row.names = FALSE)
```

##Correspondence between lineage call single vs deep

```{r}
single_lineage_poppunk$sample <- gsub("GPS_all_assemblies/","",gsub("\\.contigs.*", "", single_lineage_poppunk$sample))

single_lanes <- single_meta[,c('specnum', 'lane_id')] %>% filter(!is.na(lane_id))
single_lineage_poppunk <- single_lineage_poppunk %>% filter(sample %in% single_lanes$lane_id)
single_lineage_poppunk$specnum <- single_lanes$specnum[match(single_lineage_poppunk$sample, single_lanes$lane_id)]
single_lineage_poppunk <- single_lineage_poppunk %>% filter(specnum %in% gpsc_serotype_calls$specnum)


plotdf <- tibble(FN = sum(!paste(single_lineage_poppunk$specnum, single_lineage_poppunk$GPSC) %in% paste(gpsc_serotype_calls$specnum, gpsc_serotype_calls$GPSC)),
       TP = nrow(single_lineage_poppunk)-FN)

ggplot(melt(plotdf), aes(x=variable, y=value, fill=variable)) +
  geom_col() +
  xlab("") +
  ylab("count") +
  theme_clean(base_size = 16) +
  theme(plot.background = element_blank(),
        legend.background = element_blank()) +
  scale_fill_manual(values = c('#bcbddc','#756bb1'), guide=FALSE)

ggsave("./figures/single_vs_deep_lineage_calls_FPTN.png", width = 9, height = 7)
ggsave("./figures/single_vs_deep_lineage_calls_FPTN.pdf", width = 9, height = 7)
```


### Comparison between methods

We can now compare how the set of calls differs between latex sweeps, the mGEMs/seroba pipeline and the Serocall pipeline.

```{r}
# latex sweeps
serotypes_latex_sweep <- epi %>% group_by(specnum) %>%
  summarise(
    latex_serotypes = list(unique(c(.data$serotype1, .data$serotype2, .data$serotype3, .data$serotype4)))
  )
serotypes_latex_sweep$latex_serotypes <- map(serotypes_latex_sweep$latex_serotypes, ~.x[!is.na(.x)])

# serocall
serocalls$specnum <- manifests_qc$`DONOR ID (required for EGA)`[match(serocalls$sample, manifests_qc$`Lane Name`)]
serocalls_summary <- serocalls %>% filter(!is.na(specnum)) %>%
  group_by(specnum) %>%
  summarise(
    serocall_serotypes = list(unique(c(.data$serotype)))
  )

serotype_comparison <- gpsc_serotype_calls %>% group_by(specnum) %>%
  summarise(
    GPSC = list(unique(c(.data$GPSC))),
    seroba_serotypes = list(unique(c(.data$serotype)))
  )

serotype_comparison <- merge(serotype_comparison, serotypes_latex_sweep, by.x="specnum", by="specnum", all.x=TRUE)
serotype_comparison <- merge(serotype_comparison, serocalls_summary, by.x="specnum", by="specnum", all.x=TRUE)

comparison <- pmap_dfr(list(serotype_comparison$seroba_serotypes, 
                            serotype_comparison$latex_serotypes,
                            serotype_comparison$serocall_serotypes), function(a, b, c){
  a[a=="untypable"] <- "NT"
  a[grepl("NT", a)] <- "NT"
  a[is.na(a)] <- "NT"
  b[b=="untypable"] <- "NT"
  b[grepl("NT", b)] <- "NT"
  b[is.na(b)] <- "NT"
  c[c=="untypable"] <- "NT"
  c[grepl("NT", c)] <- "NT"
  c[is.na(c)] <- "NT"
  
  a <- a[a!="NT"]
  b <- b[b!="NT"]
  c <- c[c!="NT"]
  
  a[a=="6A/C"] <- "6A/6C"
  b[b=="6A/C"] <- "6A/6C"
  c[c=="6A/C"] <- "6A/6C"
  
  a[a=="15B/C"] <- "15B/15C"
  b[b=="15B/C"] <- "15B/15C"
  c[c=="15B/C"] <- "15B/15C"
  
  a <- unique(a)
  b <- unique(b)
  c <- unique(c)
  
  a <- map(str_split(a, "/|\\("), ~ gsub("\\(|\\)","",gsub("^0", "", .x)))
  b <- map(str_split(b, "/|\\("), ~ gsub("\\(|\\)","",gsub("^0", "", .x)))
  c <- map(str_split(c, "/|\\("), ~ gsub("\\(|\\)","",gsub("^0", "", .x)))
  
  result <- tibble(
    nSeroBA = length(a),
    nLatex = length(b),
    nSerocall = length(c),
    n_seroba_latex = sum(map_lgl(b, ~ any(.x %in% unlist(a)))),
    n_serocall_latex = sum(map_lgl(b, ~ any(.x %in% unlist(c)))),
    n_seroba_serocall = sum(map_lgl(a, ~ any(.x %in% unlist(c)))),
    nabc = sum(map_lgl(b, ~ any(.x %in% unlist(a[map_lgl(a, ~ any(.x %in% unlist(c)))])))),
    n_latex_only = length(b) - sum(map_lgl(b, ~ any(.x %in% c(unlist(a), unlist(c)))))
    )
  
  a <- map(a, ~ gsub("[A-Z]*", "", .x))
  b <- map(b, ~ gsub("[A-Z]*", "", .x))
  c <- map(c, ~ gsub("[A-Z]*", "", .x))
  
  result$n_group_seroba_latex = sum(map_lgl(b, ~ any(.x %in% unlist(a))))
  result$n_group_serocall_latex = sum(map_lgl(b, ~ any(.x %in% unlist(c))))
  result$n_group_seroba_serocall = sum(map_lgl(a, ~ any(.x %in% unlist(c))))
  result$n_group_nabc = sum(map_lgl(b, ~ any(.x %in% unlist(a[map_lgl(a, ~ any(.x %in% unlist(c)))]))))
  result$n_group_latex_only = length(b) - sum(map_lgl(b, ~ any(.x %in% c(unlist(a), unlist(c)))))
  
  return(result)
})



#Count subgroup mismatches between each method and the latex sweep
comparison_subgroup_mismatch <- pmap_dfr(list(serotype_comparison$seroba_serotypes, 
                            serotype_comparison$latex_serotypes,
                            serotype_comparison$serocall_serotypes), function(a, b, c){
  a1_g <- map(a, ~ gsub("[A-Z]*", "", .x))
  b1_g <- map(b, ~ gsub("[A-Z]*", "", .x))
  c1_g <- map(c, ~ gsub("[A-Z]*", "", .x))
  
  a[a=="untypable"] <- "NT"
  a[grepl("NT", a)] <- "NT"
  a[is.na(a)] <- "NT"
  b[b=="untypable"] <- "NT"
  b[grepl("NT", b)] <- "NT"
  b[is.na(b)] <- "NT"
  c[c=="untypable"] <- "NT"
  c[grepl("NT", c)] <- "NT"
  c[is.na(c)] <- "NT"
  
  a <- a[a!="NT"]
  b <- b[b!="NT"]
  c <- c[c!="NT"]
  
  a[a=="6A/C"] <- "6A/6C"
  b[b=="6A/C"] <- "6A/6C"
  c[c=="6A/C"] <- "6A/6C"
  
  a[a=="15B/C"] <- "15B/15C"
  b[b=="15B/C"] <- "15B/15C"
  c[c=="15B/C"] <- "15B/15C"
  
  a <- unique(a)
  b <- unique(b)
  c <- unique(c)
  
  a <- map(str_split(a, "/|\\("), ~ gsub("\\(|\\)","",gsub("^0", "", .x)))
  b <- map(str_split(b, "/|\\("), ~ gsub("\\(|\\)","",gsub("^0", "", .x)))
  c <- map(str_split(c, "/|\\("), ~ gsub("\\(|\\)","",gsub("^0", "", .x)))
  
  a_g <- map(a, ~ gsub("[A-Z]*", "", .x))
  b_g <- map(b, ~ gsub("[A-Z]*", "", .x))
  c_g <- map(c, ~ gsub("[A-Z]*", "", .x))
  
  result <- tibble(
    nSeroBA = length(a),
    nLatex = length(b),
    nSerocall = length(c),
    n_seroba_latex_subgroup_mismatch = sum(((!map_lgl(b, ~ any(.x %in% unlist(a)))) & (map_lgl(b_g, ~ any(.x %in% unlist(a_g))))) |
      map_lgl(b_g, ~ sum(unlist(a1_g) %in% .x)>1)), 
    n_serocall_latex_subgroup_mismatch =  sum((!map_lgl(b, ~ any(.x %in% unlist(c)))) & (map_lgl(b_g, ~ any(.x %in% unlist(c_g)))) |
      map_lgl(b_g, ~ sum(unlist(c1_g) %in% .x)>1))
    )
  
  return(result)
})

subgroup_mismatch <- tibble(
  method = c("mGEMS/seroBA", "serocall"),
  `mismatch count` = c(sum(comparison_subgroup_mismatch$n_seroba_latex_subgroup_mismatch),
                       sum(comparison_subgroup_mismatch$n_serocall_latex_subgroup_mismatch))
)

ggplot(subgroup_mismatch, aes(x=method, y=`mismatch count`)) + 
  geom_col() +
  theme_bw(base_size = 16) +
  ggtitle(label = "", subtitle = "count of mismatches with latex sweep unique to the subgroup level")

ggsave(filename = "./figures/serotype_subgroup_mismatch_bar.pdf", device = "pdf", width = 10, height = 7)
ggsave(filename = "./figures/serotype_subgroup_mismatch_bar.png", device = "png", width = 10, height = 7)
```

To compare the methods we generate a Venn diagram

```{r}
area1=sum(comparison$nSeroBA)
area2=sum(comparison$nSerocall)
area3=sum(comparison$nLatex)
n123=sum(comparison$nabc)
n12=sum(comparison$n_seroba_serocall) - n123
n23=sum(comparison$n_serocall_latex) - n123
n13=sum(comparison$n_seroba_latex) - n123

x <- list(`mGEMS/seroBA`= c(paste("n123", seq_len(n123)), paste("n12", seq_len(n12)), 
                            paste("n13", seq_len(n13)), paste("n1", seq_len(area1 - n123 - n12 - n13))),
          `latex sweep` = c(paste("n123", seq_len(n123)), paste("n23", seq_len(n23)), 
                            paste("n13", seq_len(n13)), paste("n3", seq_len(area3 - n123 - n23 - n13))),
          serocall = c(paste("n123", seq_len(n123)), paste("n12", seq_len(n12)), 
                            paste("n23", seq_len(n23)), paste("n2", seq_len(area2 - n123 - n12 - n23)))
          
          )
ggVennDiagram(x)
ggsave(filename = "./Figures/serotype_subgroup_venn.pdf", device = "pdf", width = 10, height = 7)
ggsave(filename = "./Figures/serotype_subgroup_venn.png", device = "png", width = 10, height = 7)


x <- list(`mGEMS/seroBA + serocall`= c(paste("n12", seq_len(n123+n13+n23)), paste("n1", seq_len(area1+area2-2*n123-n12-n23-n13))),
          `latex sweep` = c(paste("n12", seq_len(n123+n13+n23)), paste("n3", seq_len(area3 - n123 - n23 - n13))))
ggVennDiagram(x)
ggsave(filename = "./Figures/serotype_combined_method_subgroup_venn.pdf", device = "pdf", width = 10, height = 7)
ggsave(filename = "./Figures/serotype_combined_method_subgroup_venn.png", device = "png", width = 10, height = 7)

area1 <- sum(comparison$nSeroBA)
area2 <- sum(comparison$nSerocall)
area3 <- sum(comparison$nLatex) 
n123 <- sum(comparison$n_group_nabc)
n12 <- sum(comparison$n_group_seroba_serocall)  - n123
n23 <- sum(comparison$n_group_serocall_latex)  - n123
n13 <- sum(comparison$n_group_seroba_latex)  - n123

x <- list(`mGEMS/seroBA`= c(paste("n123", seq_len(n123)), paste("n12", seq_len(n12)), 
                            paste("n13", seq_len(n13)), paste("n1", seq_len(area1 - n123 - n12 - n13))),
          `latex sweep` = c(paste("n123", seq_len(n123)), paste("n23", seq_len(n23)), 
                            paste("n13", seq_len(n13)), paste("n3", seq_len(area3 - n123 - n23 - n13))),
          serocall = c(paste("n123", seq_len(n123)), paste("n12", seq_len(n12)), 
                            paste("n23", seq_len(n23)), paste("n2", seq_len(area2 - n123 - n12 - n23)))
          
          )
ggVennDiagram(x)
ggsave(filename = "./Figures/serotype_group_venn.pdf", device = "pdf", width = 10, height = 7)
ggsave(filename = "./Figures/serotype_group_venn.png", device = "png", width = 10, height = 7)
```

### Calling non-typables

The overlap between methods in identifying non-typables was considerably less consistent. For this reason we report those lineages that could not be assigned a serotype as 'unknown' rather than attempting to distinguish ambiguous serotype calls from non-typables.

```{r}
NT_comparison <- pmap_dfr(list(serotype_comparison$seroba_serotypes, 
                            serotype_comparison$latex_serotypes,
                            serotype_comparison$serocall_serotypes), function(a, b, c){
  a[a=="untypable"] <- "NT"
  a[grepl("NT", a)] <- "NT"
  a[is.na(a)] <- "NT"
  b[b=="untypable"] <- "NT"
  b[grepl("NT", b)] <- "NT"
  b[is.na(b)] <- "NT"
  c[c=="untypable"] <- "NT"
  c[grepl("NT", c)] <- "NT"
  c[is.na(c)] <- "NT"
  
  result <- tibble(
    nSeroBA = sum(a=="NT"),
    nLatex = sum(b=="NT"),
    nSerocall = sum(c=="NT")
    )
  return(result)
})

x <- list(`mGEMS/seroBA`= paste(rep(c(1:nrow(NT_comparison))[NT_comparison$nSeroBA>0], 
                                    NT_comparison$nSeroBA[NT_comparison$nSeroBA>0]),
                                unlist(map(NT_comparison$nSeroBA[NT_comparison$nSeroBA>0], seq_len))),
          `latex sweep` = paste(rep(c(1:nrow(NT_comparison))[NT_comparison$nLatex>0], 
                                    NT_comparison$nLatex[NT_comparison$nLatex>0]),
                                unlist(map(NT_comparison$nLatex[NT_comparison$nLatex>0], seq_len))),
          serocall = paste(rep(c(1:nrow(NT_comparison))[NT_comparison$nSerocall>0], 
                                    NT_comparison$nSerocall[NT_comparison$nSerocall>0]),
                                unlist(map(NT_comparison$nSerocall[NT_comparison$nSerocall>0], seq_len)))
          
          )
ggVennDiagram(x)
ggsave(filename = "./Figures/NT_venn.pdf", device = "pdf", width = 10, height = 7)
ggsave(filename = "./Figures/NT_venn.png", device = "png", width = 10, height = 7)


x <- list(`mGEMS/seroBA + serocall`= unique(c(paste(rep(c(1:nrow(NT_comparison))[NT_comparison$nSeroBA>0], 
                                    NT_comparison$nSeroBA[NT_comparison$nSeroBA>0]),
                                unlist(map(NT_comparison$nSeroBA[NT_comparison$nSeroBA>0], seq_len))),
                                paste(rep(c(1:nrow(NT_comparison))[NT_comparison$nSerocall>0], 
                                    NT_comparison$nSerocall[NT_comparison$nSerocall>0]),
                                unlist(map(NT_comparison$nSerocall[NT_comparison$nSerocall>0], seq_len))))),
          `latex sweep` = paste(rep(c(1:nrow(NT_comparison))[NT_comparison$nLatex>0], 
                                    NT_comparison$nLatex[NT_comparison$nLatex>0]),
                                unlist(map(NT_comparison$nLatex[NT_comparison$nLatex>0], seq_len))))
          

ggVennDiagram(x)
ggsave(filename = "./Figures/NT_combined_method_subgroup_venn.pdf", device = "pdf", width = 10, height = 7)
ggsave(filename = "./Figures/NT_combined_method_subgroup_venn.png", device = "png", width = 10, height = 7)
```

###Merge calls

As the serocall algorithm is able to detect serotypes at frequencies lower than the 1% threshold used in the mGEMs/seroba pipeline we take the union of the two methods when reporting serotype calls. Serocall was observed to occasionally split a single serotype into multiple within the same broader serogroup. As such we only take one instance of a serotype within the same serogroup called by serocall. As mGEMS/seroba was observed to be more specific at the serotype level we take the seroba call whenever there are conflicts between the methods.

The following code deals with naming differences between the different methods and is not the prettiest.

```{r}
merged_serotype_calls <- pmap_dfr(list(serotype_comparison$seroba_serotypes, 
                            serotype_comparison$latex_serotypes,
                            serotype_comparison$serocall_serotypes,
                            serotype_comparison$specnum), function(a, b, c, spec){
  a[a=="coverage too low"] <- NA
  a[a=="untypable"] <- NA
  a[grepl("NT", a)] <- "NT"
  a <- gsub("possible ", "", a)
  b[b=="coverage too low"] <- NA
  b[b=="untypable"] <- NA
  b[grepl("NT", b)] <- "NT"
  b[is.na(b)] <- "NT"
  c <- gsub("possible ", "", c)
  c[c=="coverage too low"] <- NA
  c[c=="untypable"] <- NA
  c[grepl("NT", c)] <- "NT"
  c[is.na(c)] <- "NT"
  c <- gsub("possible ", "", c)
  
  a[grepl("23B", a)] <- "23B"
  b[grepl("23B", b)] <- "23B"
  c[grepl("23B", c)] <- "23B"
  
  a[grepl("25A", a)] <- "38"
  # b[grepl("25A", b)] <- "38"
  # c[grepl("25A", c)] <- "38"
  
  a[a=="09A"] <- "9V"
  b[b=="09A"] <- "9V"
  c[c=="09A"] <- "9V"
  
  gpsc_serotype_calls$serotype[gpsc_serotype_calls$serotype=="25A"] <- "38"
  
  # a <- a[a!="NT"]
  # b <- b[b!="NT"]
  # c <- c[c!="NT"]
  
  orig_a <- a
  orig_b <- b
  orig_c <- c
  
  a[a=="6A/C"] <- "6A/6C"
  b[b=="6A/C"] <- "6A/6C"
  c[c=="6A/C"] <- "6A/6C"
  
  a[a=="15B/C"] <- "15B/15C"
  b[b=="15B/C"] <- "15B/15C"
  c[c=="15B/C"] <- "15B/15C"
  
  a <- map(str_split(a, "/|\\("), ~ gsub("\\(|\\)","",gsub("^0", "", .x)))
  b <- map(str_split(b, "/|\\("), ~ gsub("\\(|\\)","",gsub("^0", "", .x)))
  c <- map(str_split(c, "/|\\("), ~ gsub("\\(|\\)","",gsub("^0", "", .x)))
  
  a_group <- a
  a_group[!is.na(a)] <- map_chr(a[!is.na(a)], ~ gsub("[A-Z]*", "", .x)[[1]])
  b_group <- b
  b_group[b!="NT"] <- map_chr(b[b!="NT"], ~ gsub("[A-Z]*", "", .x)[[1]])
  c_group <- c
  c_group[c!="NT"] <- map_chr(c[c!="NT"], ~ gsub("[A-Z]*", "", .x)[[1]])
  
  orig_c <- orig_c[!duplicated(c_group)]
  c <- c[!duplicated(c_group)]
  c_group <- c_group[!duplicated(c_group)]
  
  # rename and remove ambigous calls at serotype level
  orig_a[grepl("23B", orig_a)] <- "23B"
  orig_c[grepl("23B", orig_c)] <- "23B"
  orig_a[grepl("possible 06", orig_a)] <- NA
  orig_a[orig_a=="6E(6A)"] <- "06A"
  orig_a[orig_a=="6E(6B)"] <- "06B"
  orig_a <- gsub("possible ", "", orig_a)
  orig_a[grepl("serogroup",orig_a)] <- NA
  orig_c[grepl("11",orig_c)] <- NA
  orig_c[grepl("32",orig_c)] <- NA
  orig_c[grepl("33",orig_c)] <- NA
  orig_c[grepl("6",orig_c)] <- NA
  orig_c[grepl("24",orig_c)] <- NA
  orig_c[grepl("15",orig_c)] <- NA
  
  orig_b[orig_b=="15B/C"] <- "15B/15C"
  orig_a <- gsub("^0", "", orig_a)
  orig_c <- gsub("^0", "", orig_c)
  orig_a[grepl("35", orig_a)] <- "35A/35C/42"
  orig_b[grepl("35", orig_b)] <- "35A/35C/42"
  orig_c[grepl("35", orig_c)] <- "35A/35C/42"
  orig_a[grepl("42", orig_a)] <- "35A/35C/42"
  orig_b[grepl("42", orig_b)] <- "35A/35C/42"
  orig_c[grepl("42", orig_c)] <- "35A/35C/42"
  
  a_group[a_group=='NT'] <- NA
  b_group[b_group=='NT'] <- NA
  c_group[c_group=='NT'] <- NA
  
  stopifnot(length(a_group)==length(orig_a))
  stopifnot(length(b_group)==length(orig_b))
  stopifnot(length(c_group)==length(orig_c))
  
  merged_serotypes <- orig_a
  merged_group <- a_group
  merged_serotypes <- c(merged_serotypes, orig_c[(!map_lgl(c, ~ any(.x %in% unlist(a)))) & (!map_lgl(c_group, ~ any(.x %in% unlist(merged_group))))])
  merged_group <- c(merged_group, c_group[(!map_lgl(c, ~ any(.x %in% unlist(a)))) & (!map_lgl(c_group, ~ any(.x %in% unlist(merged_group))))])
  merged_serotypes <- c(merged_serotypes, orig_b[(!map_lgl(b, ~ any(.x %in% unlist(c(a,c))))) & (!map_lgl(b_group, ~ any(.x %in% merged_group)))])
  merged_group <- unlist(c(merged_group, b_group[(!map_lgl(b, ~ any(.x %in% unlist(c(a,c))))) & (!map_lgl(b_group, ~ any(.x %in% merged_group)))]))
  
  merged_group[grepl("coverage", merged_group)] <- NA
  merged_group <- gsub("possible ", "", merged_group)
  merged_group <- gsub("serogroup ", "", merged_group)
  merged_group <- gsub("^0", "", merged_group)
  
  return(tibble(
    specnum = spec,
    merged_serotypes = list(merged_serotypes),
    merged_serogroup = list(merged_group)
  ))
    
})

#Now add estimated frequencies from the two methods
merged_serotype_calls <- map_dfr(1:nrow(merged_serotype_calls), ~ {
  tibble(
    specnum=rep(merged_serotype_calls$specnum[[.x]], length(merged_serotype_calls$merged_serotypes[[.x]])),
    serotype=merged_serotype_calls$merged_serotypes[[.x]],
    serogroup=unlist(merged_serotype_calls$merged_serogroup[[.x]])
  )
})
merged_serotype_calls$serogroup[merged_serotype_calls$serotype=="NT"] <- "NT"

serocalls$serotype[serocalls$serotype=="untypable"] <- "NA"
serocalls$serotype[grepl("NT", serocalls$serotype)] <- "NT"

serocalls$serogroup <- map_chr(serocalls$serotype, ~ ifelse(.x=="NT", "NT", gsub("[A-Z]*", "", gsub("\\(|\\)","",gsub("^0", "", unlist(str_split(.x, "/|\\(")))))))

merged_serotype_calls$serocall_percentage <- serocalls$percentage[match(paste(merged_serotype_calls$specnum, merged_serotype_calls$serogroup),
                                                               paste(serocalls$specnum, serocalls$serogroup))]

gpsc_serotype_calls$serotype[gpsc_serotype_calls$serotype %in% c("Swiss_NT", "alternative_aliB_NT")] <- "NT"


gpsc_serotype_calls$serotype[gpsc_serotype_calls$serotype %in% c("untypable")] <- NA
gpsc_serotype_calls$serotype[grepl("23B", gpsc_serotype_calls$serotype)] <- "23B"

gpsc_serotype_calls$serogroup <- map_chr(gpsc_serotype_calls$serotype, ~ ifelse(.x=="NT", "NT", 
                                                                                gsub("[A-Z]*", "", 
                                                                                     gsub("\\(|\\)","",
                                                                                          gsub("^0", "", 
                                                                                               gsub("[a-zA-Z]*", "",
                                                                                                    gsub("\\s+", "",
                                                                                               unlist(str_split(.x, "/|\\(")))))))))
gpsc_serotype_calls$serogroup[gpsc_serotype_calls$serotype=="NT"] <- "NT"
gpsc_serotype_calls$serotype[grepl("possible 06", gpsc_serotype_calls$serotype)] <- NA
gpsc_serotype_calls$serotype[gpsc_serotype_calls$serotype=="6E(6A)"] <- "06A"
gpsc_serotype_calls$serotype[gpsc_serotype_calls$serotype=="6E(6B)"] <- "06B"
gpsc_serotype_calls$serotype[gpsc_serotype_calls$serotype=="25A"] <- "38"
gpsc_serotype_calls$serotype <- gsub("^0", "", gpsc_serotype_calls$serotype)
gpsc_serotype_calls$serotype[grepl("35", gpsc_serotype_calls$serotype)] <- "35A/35C/42"
gpsc_serotype_calls$serotype[grepl("42", gpsc_serotype_calls$serotype)] <- "35A/35C/42"
gpsc_serotype_calls$serotype <- gsub("possible ", "", gpsc_serotype_calls$serotype)
gpsc_serotype_calls$serotype[grepl("serogroup", gpsc_serotype_calls$serotype)] <- NA

merged_serotype_calls$msweep_percentage <- gpsc_serotype_calls$proportion[match(paste(merged_serotype_calls$specnum, merged_serotype_calls$serogroup),
                                                               paste(gpsc_serotype_calls$specnum, gpsc_serotype_calls$serogroup))]
merged_serotype_calls$msweep_percentage <- 100*merged_serotype_calls$msweep_percentage
merged_serotype_calls$found_in_deep <- (!is.na(merged_serotype_calls$serocall_percentage)) | (!is.na(merged_serotype_calls$msweep_percentage))

# set proportions >25% that were only seen in serocall to ambigous
merged_serotype_calls$serocall_percentage[is.na(merged_serotype_calls$msweep_percentage) & 
      (!is.na(merged_serotype_calls$serocall_percentage)) &
      (merged_serotype_calls$serocall_percentage>25)] <- NA

merged_serotype_calls$serotype[grepl("15B", merged_serotype_calls$serotype)] <- "15B/15C"
merged_serotype_calls$serotype[grepl("15C", merged_serotype_calls$serotype)] <- "15B/15C"
```

### Compare serocall to mSWEEP frequencies

To further verify the results of the mGEMs pipeline we compared the inferred lineage frequencies to those inferred using serocall. Overall they appear broadly consistent and the differences are mainly due to over splitting in serocall.

```{r}
ggplot(merged_serotype_calls %>% 
         filter(serotype!="NT") %>%
         filter(!is.na(serocall_percentage)) %>%
         filter(!is.na(msweep_percentage))
         , aes(x=serocall_percentage, y=msweep_percentage)) +
  geom_point() +
  ylab("mSWEEP percentage") +
  xlab("serocall percentage") +
  theme_clean(base_size = 16) +
  theme(plot.background = element_blank(),
        legend.background = element_blank())

ggsave(filename = "./figures/mSWEEP_vs_serocall_percentage.pdf", device = "pdf", width = 10, height = 7)
ggsave(filename = "./figures/mSWEEP_vs_serocall_percentage.png", device = "png", width = 10, height = 7)

merged_serotype_calls$consensus_percentage <- merged_serotype_calls$msweep_percentage
merged_serotype_calls$consensus_percentage[is.na(
  merged_serotype_calls$consensus_percentage)] <- merged_serotype_calls$serocall_percentage[is.na(
    merged_serotype_calls$consensus_percentage)]


#add in GPSC information
merged_serotype_calls$GPSC <- gpsc_serotype_calls$GPSC[match(paste(merged_serotype_calls$specnum, merged_serotype_calls$serotype),
                                                               paste(gpsc_serotype_calls$specnum, gpsc_serotype_calls$serotype))]

# write.csv(merged_serotype_calls, "./processed_data/merged_serotype_calls.csv", row.names = FALSE, quote = FALSE)
```


### Latex sweeps vs deep sequencing

We can now compare the number of serotypes identified by deep sequencing versus latex sweeps.

```{r}
deep_counts <- merged_serotype_calls %>% 
  filter(found_in_deep) %>%
  group_by(specnum) %>%
    summarise(
      `deep seq`=n()
    )

latex_counts <- serotype_comparison %>% 
  group_by(specnum) %>%
  summarise(
    `latex sweep`=length(unlist(latex_serotypes))
  )

combined_counts <- merge(deep_counts, latex_counts, by.x="specnum", by.y="specnum", all.x = TRUE)

diff <- colSums(combined_counts[,2:ncol(combined_counts)])
(diff[[1]]-diff[[2]])/diff[[2]]
t.test(combined_counts$`deep seq`, combined_counts$`latex sweep`)

combined_counts <- melt(combined_counts)
combined_counts$variable <- as.character(combined_counts$variable)
combined_counts$variable[combined_counts$variable=='deep seq'] <- 'deep sequencing'

ggplot(combined_counts %>% filter(value>0), aes(x=value, group=variable)) + 
  geom_bar() + 
  facet_wrap(~variable, ncol = 1) +
  theme_clean(base_size = 16) +
  theme(plot.background = element_blank(),
        legend.background = element_blank()) +
  ylab("count") +
  xlab("number of unique serotypes in sample")

ggsave(filename = "./figures/nserotypes_by_method.pdf", width = 9, height = 7)
ggsave(filename = "./figures/nserotypes_by_method.png", width = 9, height = 7)

combined_counts %>% 
  group_by(variable) %>% 
  summarise(total=sum(value))


tb <- table(combined_counts$value[combined_counts$variable=='deep sequencing'])
(sum(tb)-tb[1])/sum(tb)
```

### Deep sequencing vs microarray

For a small subset of samples we also have the results of serotyping performed using microarrays.

```{r}
array_calls <- fread("./data/BUGS-SMRU multiple carriage final 04-2010.csv", 
                     data.table = FALSE, header = TRUE, skip = 1) %>% as_tibble() %>% 
  filter(`Spec num` %in% combined_counts$specnum)
array_calls$array_calls <- map(array_calls$`Array serotype result`, ~{
  .x <- gsub('\\(.*\\)', '', unlist(str_split(.x ,'\\+')))
  .x[grepl('.*NT.*', .x)] <- 'NT'
  .x <- unique(.x)
})
array_calls$num_array_calls <- map_dbl(array_calls$array_calls, length)

array_combined_counts <- combined_counts[combined_counts$specnum %in% array_calls$`Spec num`,]
array_combined_counts <- rbind(array_combined_counts, 
      tibble(specnum=array_calls$`Spec num`,
             variable='array',
             value=array_calls$num_array_calls)) 

array_combined_counts %>% 
  group_by(variable) %>%
  summarise(
    total=sum(value)
  )

t.test(array_combined_counts$value[array_combined_counts$variable=='deep sequencing'],
       array_combined_counts$value[array_combined_counts$variable=='array'])
```

### Serotype frequencies

We can now take a closer look at the frequencies with which each serotype appears in each sample

```{r}
library(ggbeeswarm)

plotdf <- merged_serotype_calls
plotdf$serotype <- factor(plotdf$serotype, levels=(merged_serotype_calls %>% 
                                                     group_by(serotype) %>%
                                                     summarise(m=sum(!is.na(consensus_percentage))) %>%
                                                     arrange(m))$serotype)

ggplot(plotdf, aes(x=serotype, y=consensus_percentage/100)) +
  geom_boxplot(alpha=0.5) +
  geom_jitter(height = 0, width = 0.1, alpha=0.5) +
  theme_clean(base_size = 16) +
  theme(plot.background = element_blank(),
        legend.background = element_blank()) +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab("proportion")

ggsave(filename = "./figures/serotype_proportions_boxplot.pdf", device = "pdf", width = 12, height = 7)
ggsave(filename = "./figures/serotype_proportions_boxplot.png", device = "png", width = 12, height = 7)

plotdf <- plotdf %>% 
  filter(!is.na(serotype)) %>%
  filter(serotype!='NT') %>%
  filter(serotype %in% names(table(plotdf$serotype))[table(plotdf$serotype)>10])
plotdf$sig <- plotdf$serotype %in% c('1','8')


gg1 <- ggplot(plotdf, aes(y=serotype, fill=sig)) +
  geom_bar() +
  theme_clean(base_size = 16) +
  theme(plot.background = element_blank(),
        legend.background = element_blank(), legend.position = 'none') +
  scale_x_sqrt(breaks=c(10, 100, 300, 600)) +
  scale_fill_manual(values = c('#1a1a1a', '#d73027')) +
  ylab('serotype') +
  xlab('count')

gg2 <- ggplot(plotdf, aes(x=serotype, y=consensus_percentage/100, col=sig)) +
  ggbeeswarm::geom_quasirandom(alpha=0.5, bandwidth = 0.5, width = 0.3) +
  theme_clean(base_size = 16) +
  theme(plot.background = element_blank(),
        legend.background = element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank()) +
  # theme(axis.text.x = element_text(angle = 90)) +
  scale_color_manual(values = c('#1a1a1a', '#d73027')) +
  ylab("frequency within host") + 
  xlab('') +
  coord_flip()

gg1 + gg2 + patchwork::plot_layout(nrow = 1)

ggsave(filename = "./figures/serotype_proportions_bee.pdf", device = "pdf", width = 10, height = 15)
ggsave(filename = "./figures/serotype_proportions_bee.png", device = "png", width = 10, height = 15)
```

A similar plot can also be constructed at the lineage level by seperating into GPSCs

```{r}
plotdf <- merged_serotype_calls 
plotdf$GPSC <- factor(plotdf$GPSC, levels=(merged_serotype_calls %>% 
                                                     group_by(GPSC) %>%
                                                     summarise(m=sum(!is.na(consensus_percentage))) %>%
                                                     arrange(-m))$GPSC)

gpsc_count <- table(plotdf$GPSC)
ggplot(plotdf %>% 
         filter(!is.na(GPSC)) %>%
         filter(GPSC %in% names(gpsc_count[gpsc_count>=10])), aes(x=as.factor(GPSC), y=consensus_percentage/100)) +
  geom_boxplot(alpha=0.5) +
  geom_jitter(height = 0, width = 0.1, alpha=0.5) +
  theme_clean(base_size = 16) +
  theme(plot.background = element_blank(),
        legend.background = element_blank()) +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab("proportion")+
  xlab("GPSC")

ggsave(filename = "./figures/GPSC_proportions_boxplot_ge10.pdf", device = "pdf", width = 12, height = 7)
ggsave(filename = "./figures/GPSC_proportions_boxplot_ge10.png", device = "png", width = 12, height = 7)
```

### Low frequency GPSCs/Serotypes

Lineages and serotypes that appear at low frequencies more than we might expect are particularly interesting as they may be systematically under sampled by methods that rely on selecting a single representative genome for surveillance.

```{r}
merged_serotype_calls$host <- swab_summary$ID[match(merged_serotype_calls$specnum, swab_summary$specnum)]

merged_serotype_calls_filt <- merged_serotype_calls %>% 
  filter(!is.na(consensus_percentage)) %>%
  filter(!is.na(serotype))

merged_serotype_calls_filt <- merged_serotype_calls_filt %>% group_by(serotype, host) %>%
  summarise(
    max_percent = max(consensus_percentage)
  )

tbl <- table(merged_serotype_calls_filt$serotype)
all_serotypes <- names(tbl)[tbl>=5]

ks_tests <- map_dfr(all_serotypes, ~{
  k <- ks.test(merged_serotype_calls_filt$max_percent, 
               merged_serotype_calls_filt$max_percent[merged_serotype_calls_filt$serotype==.x],
               alternative = "less")
  return(tibble(serotype=.x,
            statistic=k$statistic,
            p.value=k$p.value))
}) %>% arrange(p.value)

ks_tests$adj.p.value <- p.adjust(ks_tests$p.value, method="BH")

sum(ks_tests$adj.p.value<0.05)/length(tbl)
tbl <- ks_tests %>% filter(adj.p.value<0.05)
tbl$p.value <- format(tbl$p.value, digits=2)
tbl$adj.p.value <- format(tbl$adj.p.value, digits=2)
knitr::kable(tbl)
```

We can perform the same analysis but at the lineage level looking at GPSCs

```{r}
merged_serotype_calls_filt <- merged_serotype_calls %>% 
  filter(!is.na(consensus_percentage)) %>%
  filter(!is.na(GPSC))

merged_serotype_calls_filt <- merged_serotype_calls_filt %>% group_by(GPSC, host) %>%
  summarise(
    max_percent = max(consensus_percentage)
  )

tbl <- table(merged_serotype_calls_filt$GPSC)
all_GPSCs <- names(tbl)[tbl>=10]

ks_tests <- map_dfr(all_GPSCs, ~{
  k <- ks.test(merged_serotype_calls_filt$max_percent, 
               merged_serotype_calls_filt$max_percent[merged_serotype_calls_filt$GPSC==.x],
               alternative = "less")  
  return(tibble(GPSC=.x,
            statistic=k$statistic,
            p.value=k$p.value))
}) %>% arrange(p.value)

ks_tests$adj.p.value <- p.adjust(ks_tests$p.value, method="BH")

sum(ks_tests$adj.p.value<0.05)/length(tbl)

ks_tests$serotypes <- map(ks_tests$GPSC, ~{
  s <- unique(merged_serotype_calls$serotype[merged_serotype_calls$GPSC==.x])
  paste(s[!is.na(s)], collapse = ",")
})

knitr::kable(ks_tests %>% filter(adj.p.value<0.05))
```

To investigate the significant lineages and serotypes we consider histograms of the frequency with which they appear in each sample as compared to the background frequencies of all lineages.

```{r}
tplotdf1 <- plotdf
tplotdf1$serotype <- paste('serotype', plotdf$serotype)
tplotdf2 <- plotdf
tplotdf2$serotype <- 'All serotypes'
tplotdf <- rbind(tplotdf1, tplotdf2)
tplotdf <- tplotdf %>% filter(serotype %in% c('serotype 1','serotype 8','All serotypes'))
tplotdf$serotype <- factor(tplotdf$serotype, levels = c('serotype 1','serotype 8','All serotypes'))


ggplot(tplotdf, aes(x=consensus_percentage/100)) +
  geom_histogram(bins = 100) +
  facet_wrap(~serotype, ncol = 1, scales = 'free_y') +
  scale_y_continuous(n.breaks = 3) +
  theme_clean(base_size = 20) +
  theme(plot.background = element_blank(),
        legend.background = element_blank()) +
  xlab("serotype frequency") 

ggsave(filename = "./figures/serotype_proportions_historgram_significant.pdf", device = "pdf", width = 12, height = 7)



tplotdf1 <- plotdf
tplotdf1$GPSC <- paste('GPSC', plotdf$GPSC)
tplotdf2 <- plotdf
tplotdf2$GPSC <- 'All GPSCs'
tplotdf <- rbind(tplotdf1, tplotdf2)
tplotdf <- tplotdf %>% filter(GPSC %in% c('GPSC 2','GPSC 60','GPSC 42','GPSC 28', 'All GPSCs'))

tplotdf$GPSC <- factor(tplotdf$GPSC, levels = c('GPSC 2','GPSC 60','GPSC 42','GPSC 28', 'All GPSCs'))


ggplot(tplotdf, aes(x=consensus_percentage/100)) +
  geom_histogram(bins = 100) +
  facet_wrap(~GPSC, ncol = 1, scales = 'free_y') +
  scale_y_continuous(n.breaks = 3) +
  theme_clean(base_size = 20) +
  theme(plot.background = element_blank(),
        legend.background = element_blank()) +
  xlab("GPSC frequency")

ggsave(filename = "./figures/gpsc_proportions_historgram_significant.pdf", device = "pdf", width = 12, height = 7)
```

### Interactions between serotypes

We consider to carriage episode estimates. This uses a simple mash distance cutoff based upon the mash distances of within host and between host mGEMS inferred genomes.

```{r}
# Load carriage estimates
conservative_carriage_estimates <- fread("./data/carriage_episode_estimates.csv", data.table = FALSE) %>% as_tibble()
merged_serotype_calls$carriage_episode <- conservative_carriage_estimates$carriage_episode[
  match(paste(merged_serotype_calls$specnum, merged_serotype_calls$GPSC),
        paste(conservative_carriage_estimates$specnum, conservative_carriage_estimates$GPSC))
]
```

```{r, eval=FALSE}
merged_serotype_calls_filt <- merged_serotype_calls
merged_serotype_calls_filt$serotype[is.na(merged_serotype_calls_filt$serotype)] <- "NA"
tbl <- table(merged_serotype_calls_filt$serotype, useNA = 'ifany')
merged_serotype_calls_filt <- merged_serotype_calls_filt %>% filter(serotype %in% names(tbl)[tbl>=5])


all_specnums <- unique(merged_serotype_calls_filt$specnum)
all_serotypes <- unique(merged_serotype_calls_filt$serotype)

pairs <- t(combn(all_serotypes, 2))
model_fits <- map_dfr(1:nrow(pairs), function(i){
  pa <- matrix(0, nrow = length(all_specnums), ncol = 2,
       dimnames = list(all_specnums, pairs[i,]))
  pa[merged_serotype_calls_filt$specnum[merged_serotype_calls_filt$serotype==pairs[i,1]],1] <- 1
  pa[merged_serotype_calls_filt$specnum[merged_serotype_calls_filt$serotype==pairs[i,2]],2] <- 1
  
  dat <- as_tibble(cbind(all_specnums, pa))
  dat$carriage_episode <- merged_serotype_calls_filt$carriage_episode[match(dat$all_specnums, merged_serotype_calls_filt$specnum)]
  colnames(dat) <- c('specnum', 'seroA', 'seroB', 'carriage_episode')
  dat$seroA <- dat$seroA=="1"
  dat$seroB <- dat$seroB=="1"

  model <- lme4::glmer(seroA ~ seroB + (1|carriage_episode), data = dat, family = binomial,
                       nAGQ=0) %>%
    broom::tidy()
  
  return(tibble(
    serotypeA = pairs[i,1],
    serotypeB = pairs[i,2],
    statistic=model$statistic[model$term=="seroBTRUE"],
    p.value=model$p.value[model$term=="seroBTRUE"]
  ))
  
})

model_fits$adj.p.value <- p.adjust(model_fits$p.value, method="BH")
model_fits <- model_fits[order(model_fits$p.value),]
model_fits[model_fits$adj.p.value<0.05,]

write.csv(model_fits, file="data/pairwise_serotype_comparison_msweep.csv", quote = FALSE, row.names = FALSE)
```

```{r}
model_fits <- fread("data/pairwise_serotype_comparison_msweep.csv", data.table = FALSE) %>% as_tibble()
knitr::kable(model_fits %>% filter(p.value<0.05))
```

We can look to see if there are any strong associations at the GPSC level.

```{r, eval=FALSE}
tbl <- table(merged_serotype_calls$GPSC)
merged_serotype_calls_filt <- merged_serotype_calls %>% filter(GPSC %in% names(tbl)[tbl>=5])

all_specnums <- unique(merged_serotype_calls_filt$specnum)
all_GPSCs <- unique(merged_serotype_calls_filt$GPSC)
length(all_GPSCs)
pairs <- t(combn(all_GPSCs, 2))
model_fits <- map_dfr(1:nrow(pairs), function(i){
  print(i)
  pa <- matrix(0, nrow = length(all_specnums), ncol = 2,
       dimnames = list(all_specnums, pairs[i,]))
  pa[merged_serotype_calls_filt$specnum[merged_serotype_calls_filt$GPSC==pairs[i,1]],1] <- 1
  pa[merged_serotype_calls_filt$specnum[merged_serotype_calls_filt$GPSC==pairs[i,2]],2] <- 1
  
  dat <- as_tibble(cbind(all_specnums, pa))
  dat$carriage_episode <- merged_serotype_calls_filt$carriage_episode[match(dat$all_specnums, merged_serotype_calls_filt$specnum)]
  colnames(dat) <- c('specnum', 'GPSC_A', 'GPSC_B', 'carriage_episode')
  dat$GPSC_A <- dat$GPSC_A=="1"
  dat$GPSC_B <- dat$GPSC_B=="1"

  model <- lme4::glmer(GPSC_A ~ GPSC_B + (1|carriage_episode), data = dat, family = binomial,
                       nAGQ=0) %>%
    broom::tidy()
  
  return(tibble(
    serotypeA = pairs[i,1],
    serotypeB = pairs[i,2],
    statistic=model$statistic[model$term=="GPSC_BTRUE"],
    p.value=model$p.value[model$term=="GPSC_BTRUE"]
  ))
  
})

model_fits$adj.p.value <- p.adjust(model_fits$p.value, method="BH")
model_fits <- model_fits[order(model_fits$p.value),]
model_fits[model_fits$adj.p.value<0.05,]

write.csv(model_fits, file="data/pairwise_GPSC_comparison_msweep.csv", quote = FALSE, row.names = FALSE)
```

```{r}
model_fits <- fread("data/pairwise_GPSC_comparison_msweep.csv", data.table = FALSE) %>% as_tibble()
knitr::kable(model_fits %>% filter(p.value<0.05))
```

### Carriage Differences between Mothers and Infants

```{r}
merged_serotype_calls$host <- paste(swab_summary$codenum, swab_summary$category, sep="_")[match(merged_serotype_calls$specnum,swab_summary$specnum)]
merged_serotype_calls$category <- swab_summary$category[match(merged_serotype_calls$specnum,swab_summary$specnum)]

serotypes <- merged_serotype_calls$serotype
serotypes <- unique(serotypes)
serotypes <- serotypes[!is.na(serotypes) & serotypes!='NT']

sero_mother_vs_child <- map_dfr(serotypes, ~{
  td <- merged_serotype_calls %>% 
    group_by(host, category) %>%
    summarise(
      has_sero=.x %in% serotype, .groups = 'keep'
    )
  tidy(fisher.test(td$category, td$has_sero)) %>% 
    add_column(serotype=.x, .before = 1) %>%
    add_column(prop_mother=sum(td$category=="Mother" & td$has_sero)/sum(td$category=="Mother")) %>%
    add_column(prop_infant=sum(td$category=="Infant" & td$has_sero)/sum(td$category=="Infant"))
}) %>% 
  arrange(p.value) %>%
  mutate(adj.p.value=p.adjust(p.value, method = 'BH'))

gpscs <- merged_serotype_calls$GPSC
gpscs <- unique(gpscs)
gpscs <- gpscs[!is.na(gpscs) & gpscs!='']

gpsc_mother_vs_child <- map_dfr(gpscs, ~{
  td <- merged_serotype_calls %>% 
    filter(!is.na(GPSC)) %>%
    group_by(host, category) %>%
    summarise(
      has_sero=.x %in% GPSC, .groups = 'keep'
    )
  tidy(fisher.test(td$category, td$has_sero)) %>% 
    add_column(GPSC=.x, .before = 1) %>%
    add_column(prop_mother=sum(td$category=="Mother" & td$has_sero)/sum(td$category=="Mother")) %>%
    add_column(prop_infant=sum(td$category=="Infant" & td$has_sero)/sum(td$category=="Infant"))
}) %>% 
  arrange(p.value) %>%
  mutate(adj.p.value=p.adjust(p.value, method = 'BH'))
data.table(gpsc_mother_vs_child)

write.csv(sero_mother_vs_child, file = "./data/fisher_test_sero_mother_vs_child.csv", row.names = FALSE, quote = FALSE)
write.csv(gpsc_mother_vs_child, file = "./data/fisher_test_gpsc_mother_vs_child.csv", row.names = FALSE, quote = FALSE)

plotdf <- melt(gpsc_mother_vs_child[gpsc_mother_vs_child$adj.p.value<0.05,c('GPSC', 'prop_mother', 'prop_infant')], id.vars='GPSC')
plotdf$GPSC <- factor(plotdf$GPSC)
plotdf$category <- ifelse(plotdf$variable=='prop_mother', 'mother', 'infant')
ggplot(plotdf, aes(x=GPSC, y=value, fill=category)) + 
  geom_col(position = 'dodge') +
  theme_clean(base_size = 20) +
  theme(plot.background = element_blank(),
        legend.background = element_blank()) +
  scale_fill_manual(values = c('#377eb8', '#4daf4a')) +
  ylab('proportion of hosts with GPSC') +
  xlab("GPSC")

ggsave("./figures/fisher_test_gpsc_mother_vs_child.png", width = 9, height = 7)
ggsave("./figures/fisher_test_gpsc_mother_vs_child.pdf", width = 9, height = 7)


plotdf <- melt(sero_mother_vs_child[sero_mother_vs_child$adj.p.value<0.05,c('serotype', 'prop_mother', 'prop_infant')], id.vars='serotype')
plotdf$category <- ifelse(plotdf$variable=='prop_mother', 'mother', 'infant')
ggplot(plotdf, aes(x=serotype, y=value, fill=category)) + 
  geom_col(position = 'dodge') +
  theme_clean(base_size = 20) +
  theme(plot.background = element_blank(),
        legend.background = element_blank()) +
  scale_fill_manual(values = c('#377eb8', '#4daf4a')) +
  ylab('proportion of hosts with GPSC') +
  xlab("serotype")
ggsave("./figures/fisher_test_sero_mother_vs_child.png", width = 9, height = 7)
ggsave("./figures/fisher_test_sero_mother_vs_child.pdf", width = 9, height = 7)


td <- merged_serotype_calls %>% 
  group_by(specnum, host, category) %>%
  summarise(
    nsero=n()
  ) %>% 
  group_by(host, category) %>%
  summarise(
    mean_nsero=mean(nsero)
  )
t.test(td$mean_nsero[td$category=='Mother'], td$mean_nsero[td$category=='Infant'])

ggplot(td, aes(x=category, y=mean_nsero, col=category)) +
  geom_boxplot(outlier.colour = NA) +
  geom_jitter(height = 0, width = 0.1) +
  ylab("mean number of serotypes by host") +
  xlab("") +
  theme_clean(base_size = 20) +
  theme(plot.background = element_blank(),
        legend.background = element_blank()) +
  scale_colour_manual(values = c('#377eb8', '#4daf4a'), guide=FALSE)
ggsave("./figures/fisher_test_moi_mother_vs_child.png", width = 9, height = 7)
ggsave("./figures/fisher_test_moi_mother_vs_child.pdf", width = 9, height = 7)


table(merged_serotype_calls$serotype)[order(table(merged_serotype_calls$serotype))]
table(merged_serotype_calls$GPSC)[order(table(merged_serotype_calls$GPSC))]

merged_mothers <- merged_serotype_calls %>% filter(category=="Mother")
table(merged_mothers$serotype)[order(table(merged_mothers$serotype))]
```

## Association with Multiple Carriage

The association of lineages with multiple carriage, as well as virulence and resistance determinants, can provide important clues as to the ability of different features to coexist with other strains. Lineages and features that are more often found in mixed infections are also prone to being missed in genomic surveys that focus only on single colony picks. Thus identifying the relationship between different lineages and instances of multiple carriage is important for both the surveillance of the pathogen and in understanding the competition between lineages within the host.

We considered whether certain lineages and features of interest were more likely to be found in multiple carriage, treating multiple carriage as a binary dependent variable. We used a complementary log-log link function to account for the expected increase in prevalence of a feature that would occur simply because a larger number of lineages are sampled in multiple infections. As an extreme example, if we were to sample a mixed infection with one million lineages there would be a very high likelihood we would observe resistance within the mixture. However, this would not necessarily be due to an association with multiple carriage but rather due to the very large number of lineages present. This is a similar problem to that seen in ecology in the study of nest success where the overall age of the nest must be accounted for \cite{Shaffer2004-xl}.

Using the complementary log-log link function we used a Generalised Linear Mixed Model to identify associations between multiple carriage and specific lineages or serotypes and corrected for multiple testing with the BH method.

To control for the impacts of antimicrobial treatment we include treatment as a covariate. We use the same classification as that described in the GWAS analysis.

```{r}
abx_summary <- fread("./data/epi/Pneumo-DEEP_illness_abx_summary.csv", data.table = FALSE) %>% as_tibble

#map samples with treatment status
abx_summary$ID <- paste(abx_summary$codenum, "Infant", sep="-")
abx_summary$date_start <- lubridate::as_date(abx_summary$date_start)

#add treatment information
swab_summary$treatment <- map_chr(1:nrow(swab_summary), function(i){
  sampleID <- swab_summary$ID[[i]]
  treatments <- abx_summary[abx_summary$ID==sampleID,]
  treatments <- treatments[!is.na(treatments$drug1),]
  diff <- swab_summary$specdate[[i]]-treatments$date_start
  if (any((diff>0) & (diff<=28))){
    return("TREATED")
  } else if (any((diff>0) & (diff<60))) {
    return("AMBIGUOUS")
  } else {
    return("NOT_TREATED")
  }
})
```

We can now run the regression at the lineage (GPSC) level. We use a generalised mixed model with the host as a random variable to account for repeated samples from the same carriage episode.

```{r}
gpscs_filt <- merged_serotype_calls
gpscs_filt$GPSC[is.na(gpscs_filt$GPSC)] <- "unknown"
gpscs <- unique(gpscs_filt$GPSC)
specnums <- unique(gpscs_filt$specnum)
gpsc_pa <- matrix(FALSE, nrow = length(specnums), ncol = length(gpscs),
                      dimnames = list(specnums, gpscs))
gpsc_pa[cbind(gpscs_filt$specnum, gpscs_filt$GPSC)] <- TRUE
gpsc_pa <- as_tibble(gpsc_pa) %>% add_column(specnum=specnums, .before = 1)
gpsc_pa$num_gpsc <- map_dbl(gpsc_pa$specnum, ~ sum(gpscs_filt$specnum==.x & !is.na(gpscs_filt$consensus_percentage)))
gpsc_pa <- gpsc_pa[gpsc_pa$num_gpsc>0,]
gpsc_pa <- melt(gpsc_pa, id.vars=c('specnum', 'num_gpsc'), variable.name='GPSC', value.name='pa')
gpsc_pa$host <- paste(swab_summary$codenum, swab_summary$category, sep="_")[match(gpsc_pa$specnum,swab_summary$specnum)]
gpsc_pa$treated <- swab_summary$treatment[match(gpsc_pa$specnum,swab_summary$specnum)]=='TREATED'

gpsc_glm_tests <- map_dfr(gpscs[gpscs!='unknown'], ~{
  temp_data <- gpsc_pa %>% filter(GPSC==.x)
  if(sum(table(temp_data$pa)>=20) <2) return(tibble())
  temp_data$multi <- temp_data$num_gpsc>1

  tidy(glmer(pa ~ multi + treated + (1|host), data = temp_data, family = binomial(link = "cloglog"), nAGQ = 0)) %>%
    filter(term=='multiTRUE') %>%
    add_column(GPSC=.x, .before = 1)
}) %>%
  arrange(p.value) %>%
  mutate(adj.p=p.adjust(p.value, method="BH"))

gpsc_glm_tests$serotypes <- map_chr(gpsc_glm_tests$GPSC, ~{
  s <- unique(merged_serotype_calls$serotype[merged_serotype_calls$GPSC==.x])
  paste(s[!is.na(s)], collapse = ",")
})

knitr::kable(gpsc_glm_tests %>% filter(p.value<0.1))
```

We can now generate a plot of the multiple carriage frequency of the lineages found to be significantly predictive of multiple carriage. Interestingly, GPSC1 is associated with being found less frequently in multiple carriage.

```{r}
topplot <- gpsc_glm_tests %>% filter(adj.p<0.05)

topplot <- map_dfr(gpsc_glm_tests$GPSC, ~{
  temp_data <- gpsc_pa %>% filter(GPSC==.x) %>% filter(pa)
  temp_data$multi <- temp_data$num_gpsc>1
  return(tibble(
    GPSC=.x,
    freq_multi=sum(temp_data$multi)/nrow(temp_data)
    ))
})

m <- mean(topplot$freq_multi)

topplot <- topplot %>% filter(GPSC %in% gpsc_glm_tests$GPSC[gpsc_glm_tests$adj.p<0.05])

ggplot(topplot, aes(x=GPSC, y=freq_multi)) +
  geom_col() +
  geom_hline(aes(yintercept=m), col='red', size=1) +
  ylab('multiple carriage frequency') +
   theme_clean(base_size = 20) +
  theme(plot.background = element_blank(),
        legend.background = element_blank()) 

ggsave("./Figures/multiple_carriage_freq_barplot_top.pdf", width = 12, height = 7)
```

We can perform a similar analysis at the serotype level.

```{r}
sero_filt <- merged_serotype_calls
sero_filt$serotype[is.na(sero_filt$serotype)] <- 'unknown'
serotypes <- unique(sero_filt$serotype)
specnums <- unique(sero_filt$specnum)
serotype_pa <- matrix(FALSE, nrow = length(specnums), ncol = length(serotypes),
                      dimnames = list(specnums, serotypes))
serotype_pa[cbind(sero_filt$specnum, sero_filt$serotype)] <- TRUE
serotype_pa <- as_tibble(serotype_pa) %>% add_column(specnum=specnums, .before = 1)
serotype_pa$num_sero <- map_dbl(serotype_pa$specnum, ~ sum(sero_filt$specnum==.x & !is.na(sero_filt$consensus_percentage)))
serotype_pa <- serotype_pa[serotype_pa$num_sero>0,]
serotype_pa <- melt(serotype_pa, id.vars=c('specnum', 'num_sero'), variable.name='serotype', value.name='pa')
serotype_pa$host <- paste(swab_summary$codenum, swab_summary$category, sep="_")[match(serotype_pa$specnum,swab_summary$specnum)]
serotype_pa$treated <- swab_summary$treatment[match(serotype_pa$specnum,swab_summary$specnum)]=='TREATED'

serotype_glm_tests <- map_dfr(serotypes, ~{
  temp_data <- serotype_pa %>% filter(serotype==.x)
  if(sum(table(temp_data$pa)>5) <2) return(tibble())
  temp_data$multi <- (1*temp_data$num_sero>1)

  tidy(glmer(pa ~ multi + treated + (1|host), data = temp_data, family = binomial(link = "cloglog"), nAGQ = 0)) %>%
    filter(term=='multiTRUE') %>%
    add_column(serotype=.x, .before = 1)
}) %>%
  arrange(p.value) %>%
  mutate(adj.p=p.adjust(p.value, method="BH"))

knitr::kable(serotype_glm_tests %>% filter(p.value<0.1))
```

